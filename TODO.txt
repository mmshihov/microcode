-) Можно сделать файл с индивидуальным заданием (с защитой! подписанным)

62) Прошивка сложения в ПЗ:
        00:0 00 01 00001 ready
        01:0 02 02 01114 read 1st
        02:0 03 03 01224 read 2nd
        03:0 04 04 08200 sub chars
        04:4 06 05 00000
        05:0 0f 0f 00200
        06:5 09 07 00000
        07:0 08 08 00110
        08:0 0f 0f 00220
        09:2 0c 0a 00000 equalise chars
        0a:6 0e 0b 00000 shift 1st loop
        0b:0 0a 0a 00440
        0c:6 0e 0d 00000 shift 2nd loop
        0d:0 0c 0c 02808
        0e:0 0f 0f 00220 mantiss addition
        0f:7 17 10 00000 mantiss correction
        10:8 15 11 00000
        11:0 12 12 00080 neg shl
        12:8 14 13 00000
        13:0 11 11 00800
        14:2 20 29 00000
        15:0 16 16 00400
        16:3 20 26 00000
        17:8 1a 18 00000
        18:0 19 19 00400
        19:3 20 23 00000
        1a:9 1b 1c 00000
        1b:0 20 20 00100
        1c:0 1d 1d 00080 pos shl
        1d:8 1e 1f 00000
        1e:0 1c 1c 00800
        1f:2 20 29 00000
        20:1 20 21 00002 result
        21:0 22 22 80000
        22:0 00 00 40000
        23:1 23 24 00002 pos_prs
        24:0 25 25 A0000
        25:0 00 00 40000
        26:1 26 27 00002 neg_prs
        27:0 28 28 90000
        28:0 00 00 40000
        29:1 29 2a 00002 pmr
        2a:0 2b 2b b0000
        2b:0 00 00 40000

61) FIXED: Сложение в ПЗ. Неверное отображение (определение) осведомительного сигнала p9.
    Ошибка в АЛУ, отображение верное!

60) В псевдоасме, сложение в ПЗ
            ready_loop:
            00:{'ready'} //(0) 00001
                if (p0=0) goto ready_loop
                else      goto next

            01:{RG1:=(D[14],D[14:6]); CT2:=(0,0,D[5:0]); RG2:=0; CT1:=0;} //(12,8,4,2) 01114 читаем первый операнд A
                goto next

            02:{RG2:=RG2+RG1; CT1:=CT1+CT2; RG1:=(D[14],D[14:6]); CT2:=(0,0,D[5:0]);} //(12,9,5,2) 01224 читаем второй операнд B
                goto next

            03:{CT1:=CT1-CT2;} //(15,9) 08200 вычитаем характеристики (CA-CB), с мантиссами работать рано
                goto next

            04:{}
                if (p4=0) goto CHECK_LE_MINUS_10
                else      goto next

            05:{CT1:=CT1+CT2;} //(9) 00200
                 goto MANTISS_CORRECTION:;

            CHECK_LE_MINUS_10:
            06:{}
                if (p5 = 0) goto EQUALISE_CHARS
                else        goto next

            07:{CT1:=0; RG2:=0;} //(8,4) 00110
                goto next;

            08:{CT1:=CT1+CT2; RG2:=RG2+RG1;} //(5,9) 00220
                goto MANTISS_CORRECTION

            EQUALISE_CHARS:
            09:{}
                if (p2 = 0) goto SHIFT_ARG_2
                else        goto next

            SHIFT_ARG_1:
            0a:{}
                if (p6 == 0) goto MANTISS_ADDITION
                else         goto next

            0b:{RG2 := SHR(RG2); CT1:=CT1+1;} //(6,10) 00440
                 goto SHIFT_ARG_1

            SHIFT_ARG_2:
            0c:{}
                if (p6 == 0) goto MANTISS_ADDITION
                else         goto next

            0d:{RG1 := SHR(RG1); CT2:=CT2+1; CT1:=CT1-1;} //(3,11,13) 02808
                 goto SHIFT_ARG_2

            MANTISS_ADDITION:
            0e:{RG2:=RG2+RG1; CT1:=CT1+CT2;} //(5,9) 00220
                goto next;

            MANTISS_CORRECTION:
            0f:{}
                if (p7 = 0) goto MR_GE_0
                else        goto next;

            10:{}
                if (p8 = 0) goto MR_LT_0_NORMALISED
                else        goto next;

            NEG_SHL:
            11:{RG2:=SHL(RG2);} //(7) 00080
                goto next;

            12:{}
                if (p8 = 0) goto CHECK_PMR
                else        goto next

            13:{CT1:=CT1-1;} //(11) 00800
                goto NEG_SHL;

            CHECK_PMR:
            14:{}
                if (p2 = 0) goto RESULT
                else        goto PMR

            MR_LT_0_NORMALISED:
            15:{CT1:=CT1+1;} //(10) 00400
                goto next;

            16:{}
                if (p3 = 0) goto RESULT
                else        goto NEG_PRS

            MR_GE_0:
            17:{}
                if (p8 = 0) goto MR_GE_0_TO_NORMALISE
                else        goto next

            18:{CT1:=CT1+1;} //(10) 00400
                goto next;

            19:{}
                if (p3 = 0) goto RESULT;
                else        goto POS_PRS;

            MR_GE_0_TO_NORMALISE:
            1a:{}
                if (p9 = 0) goto next
                else        goto POS_SHL

            1b:{CT1:=0; } //(8) 00100
                goto RESULT;

            POS_SHL:
            1c:{RG2:=SHL(RG2);} //(7) 00080
                goto next

            1d:{}
                if (p8 = 0) goto next
                else        goto POS_PMR_CHECK

            1e:{CT1:=CT1-1;} //(11) 00800
                goto POS_SHL;

            POS_PMR_CHECK:
            1f:{}
                if (p2 = 0) goto RESULT
                else        goto PMR

            RESULT:
            20:{result} //(1) 00002
                if (p1 = 0) goto RESULT
                else        goto next

            21:{'success';} //(19) 80000
                goto next

            22:{data} //(18) 40000
                goto ready_loop

            POS_PRS:
            23:{result} //(1) 00002
                if (p1 = 0) goto POS_PRS
                else        goto next

            24:{'success';} //(19,17) A0000
                goto next

            25:{data} //(18) 40000
                goto ready_loop

            26:NEG_PRS:
            {result} //(1) 00002
                if (p1 = 0) goto NEG_PRS
                else        goto next

            27:{'success';} //(19,16) 90000
                goto next

            28:{data} //(18) 40000
                goto ready_loop

            29:PMR:
            {result} //(1) 00002
                if (p1 = 0) goto PMR
                else        goto next

            2A:{'success';} //(19,17,16) B0000
                goto next

            2B:{data} //(18) 40000
                goto ready_loop

59) DONE: Ошибка в первом способе беззнакового деления --- младший разряд частного заполняется только нулями...
    Микропрограмма:
        0: 0 00 01 0001
        1: 0 02 02 0120
        2: 0 03 03 0014
        3: 3 06 04 0000
        4: 0 05 05 0040
        5: 0 08 08 0280
        6: 0 07 07 0040
        7: 0 08 08 0200
        8: 0 09 09 0408
        9: 2 03 0a 0000
        a: 3 0b 0c 0000
        b: 0 0c 0c 0200
        c: 1 0c 0d 0002
        d: 0 0e 0e 0800
        e: 0 00 00 1000
58) Алгоритм сложения в формате с плавающей точкой:
    {RG1:=(D[14],D[14:6]); CT2:=(0,0,D[5:0]); RG2:=0; CT1:=0;} //(12,8,4,2) 01114 читаем первый операнд A
    {RG2:=RG2+RG1; CT1:=CT1+CT2; RG1:=(D[14],D[14:6]); CT2:=(0,0,D[5:0]);} //(12,9,5,2) 01224 читаем второй операнд B
    {CT1:=CT1-CT2; } //(15,9) 08200 вычитаем характеристики (CA-CB), с мантиссами работать рано
    if (p4) { //CA-CB >= 10
        //восстанавливаем и выдаем A:
        {CT1:=CT1+CT2; goto MANTISS_CORRECTION;} //(9) 200
    }
    if (p5) { //CA-CB <= -10
        //выдаем B
        {CT1:=0; RG2:=0;} //(8,4) 110
        {CT1:=CT1+CT2; RG2:=RG2+RG1; goto MANTISS_CORRECTION;} //(5,9) 220
    }

    //выравнивание характеристик
    if (p2) { //CA-CB < 0; CB>CA
        B_SHIFT:
        if (p6) { //CT1 == 0
            {RG2 := SHR(RG2); CT1:=CT1+1; goto B_SHIFT} //(6,10) 440
        }
    } else {
        A_SHIFT:
        if (p6) { //CT1 == 0
            {RG1 := SHR(RG1); CT2:=CT2+1; CT1:=CT1-1; goto A_SHIFT} //(6,11,13) 244
        }
    }

    //сложение мантисс! перенос характеристик!
    {RG2:=RG2+RG1; CT1:=CT1+CT2;} //(5,9) 220

    MANTISS_CORRECTION:
    if (p7) { //mr < 0
        if (p8) {
            //11, нужно выполнять нормализацию, сдвигая мантиссу результата влево
            NEG_SHL:
            {RG2:=SHL(RG2);} //(7) 80
            if (p8) {
                {CT1:=CT1-1; goto NEG_SHL;} //(11) 800
            }
            if (p2) { //ПМР
                goto PMR;
            }
        } else {
            //10, нужно увеличить характеристику результата на 1
            {CT1:=CT1+1;} //(10) 400
            if (p3) {
                goto NEG_PRS;
            }
        }
    } else {
        if (p8) {
            //01 нужно увеличить характеристику результата на 1
            {CT1:=CT1+1;} //(10) 400
            if (p3) {
                goto POS_PRS;
            }
        } else {
            //00
            if (!p9) {
                {CT1:=0; goto RESULT;} //(8) 100
            }

            POS_SHL:
            {RG2:=SHL(RG2);} //(7) 80
            if (!p8) {
                {CT1:=CT1-1; goto POS_SHL;} //(11) 800
            }
            if (p2) { //ПМР
                goto PMR;
            }
        }
    }

    RESULT:
    POS_PRS:
    NEG_PRS:
    PMR:

57) NOTE: Русификация:
    1) В *.pro файле добавляем:

    TRANSLATIONS += \
        translate/microcode_ru.ts


    2) Компонуем (обновляем) XML-файл с переводом (translate/microcode_ru.ts) с помощью lupdate:

    QT Console (Qt 5.0.1 for Desctop MinGW 4.7)
    //переходим в папку с проектом
    > c:\work\informatics\dev\informatics\software\microcode>cd work\informatics\dev\informatics\software\microcode
    //обновляем файл перевода (translate/microcode_ru.ts)
    > lupdate microcode.pro

    3) Запускаем графический Qt Linguist, открываем в нем microcode_ru.ts и выполняем перевод (там все интуитивно).

    4) После того, как все сделано выполняем lrelease, чтобы создать файл словаря (microcode_ru.qm).

        > cd translate
        > lrelease microcode_ru.ts

        На выходе --- *.qm-файл, это бинарник, он сжат, оптимизирован и пр...
        Его обычно запихивают в ресурсы (в этом проекте так и сделано).
        Код для перехода на др язык см в main.

56) DONE: Fadd. Состояние ms1 в Fadd не обновляется --- сделать его в 16сс. Вывод в BD2 также в HEX.
55) DONE: Версию софта в титул!
54) DONE: Сложение в ПЗ --- отладить алгоритм сложения (в CFaddTestVector)
53) Идея для методички:
    Алгоритм приема лабораторнорй работы
    1) Прием в режиме отладки.
        Трюк: Просить ввести аргументы в десятичной системе счисления.
        Цель: Оценить как студенты понимают представления чисел и умеют ли представлять числа в 2СС.
    2) В умножении в прямом коде давать примеры, в которых установлен старший бит модуля.
       Например, перемножение 1,1000001 * 0,0000001 (-65(мн-ль) * 1):
        Трюк: Например, в первом способе количество сдвигов и анализов отличается: сдвигов 6, анализов 7.
        Цель: Качество понимания и составления алгоритма умножения.
    3) В ручном режиме. Просить закодировать управляющий вектор (задав какие y надо подавать).
    4) В формате с плавающей точкой: просить ввести операнд в 10 сс.
52) FIXED: Fadd. Диалог ввода аргументов --- не работает!
51) Fadd. Обновление мультиплексоров ошибок и шинных драйверов!
50) DONE: (для сложения с плавающей запятой!): Обработка ошибок!!!
    В случае алгоритмов умножения в этом нет необходимости --- результат всегда определен и ошибок нет.
    В случае, например, деления результат невозможно определить, когда делитель --- ноль.
    В этом случае добавляем к шинному циклу код ошибки (КОШ), который передаем первым.

                                (КОШ,Результат1,Результат2,...)

    Если результат корректен, когда КОШ равен нулю. В остальных случаях проверка значения
    результата зависит от значения КОШ.
49) DONE: Переделать первый способ --- он некошерный (должен быть n-разрядный сумматор):
        00: 0 00 01 0001 Ждем: Готов
        01: 0 02 02 0410 Читаем_А: Rg1:=D[6:0]; T1:=D[7]
        02: 0 03 03 08c4 Читаем_Б: Rg2:=D[6:0]; T2:=D[7], Rg3:=0; Ct1:=1
        03: 3 05 04 0000 Анализ_Множителя: if(p3) goto Сдвигаем else goto Наращиваем
        04: 0 05 05 0100 Наращиваем: Rg3:=Rg3+Rg2;
        05: 0 06 06 0228 Сдвигаем: shl(Rg3,Rg4); Ct1:=Ct1+1
        06: 2 03 07 0000 Анализ_ЭтоКонец: if (p2) goto Анализ_Множителя else goto Ждем_Шину
        07: 1 07 08 0002 Ждем_Шину:if (p2) goto Выдаем_младшую_часть else goto Ждем_Шину
        08: 0 09 09 2000 Выдаем_младшую_часть: D=BD2
        09: 0 00 00 1000 Выдаем_старшую_часть: D=BD1
48) DONE: Мур --- автотесты деления первым способом с автоматическим восстановлением остатка
        00:0 00 01 00001
        01:0 02 02 00514
        02:0 03 03 008a0
        03:0 05 05 00a00
        04:0 05 05 00800
        05:0 06 06 02000
        06:2 07 08 00008
        07:3 04 03 01000
        08:3 09 0a 00000
        09:0 0a 0a 00800
        0a:1 0a 0b 00002
        0b:0 0c 0c 04000
        0c:0 00 00 08000
47) В каждом методе DoSpreadInput выполняется проверка IsError... унести её вверх по иерархии
   в родительский SpreadInput...
46) DONE: Текущее задание в WindowTitle
45) DONE: Функцию 'ошибка теста', если не пройден тест...
44) DONE: Концепция: загрузку микропрограммы из файла не делать! Набирать только ручками!
43) FIXED: При переходе в режим выполнения надо запрещать actions смены MCU
42) FIXED: Проверить удаление Hint из модели...
40) NOTE: Тесты стартового задания (перевод ПК в ДК) пройдены вручную (в автоматическом и ручном режимах, автотесты Мура)
41) NOTE: Поменял физические сигналы в CPU: Было {p0-'BUS',p1-'TASK'} стало {p0-'TASK',p1-'BUS'}
          Прошивки тестов недействительны!!!
40) DONE: Ручная коррекция --- минимум управляющих сигналов (задет "ДК РК 1")
39) DONE: Плавное изменение слайдера между таблицей микропрограммы и
38) DONE: Эмблема
37) DONE: Мур --- четвертый способ ДК АК
        0:0 00 00 01 01 0001
        1:0 02 02 02 02 0284 сброс СТ
        2:0 03 03 03 03 0090 инкремент СТ
        3:1 06 04 05 06 0000
        4:0 06 06 06 06 0400
        5:0 06 06 06 06 0440
        6:2 07 08 07 08 0000
        7:0 03 03 03 03 0128
        8:0 08 09 08 09 0002
        9:0 0a 0a 0a 0a 1000
        a:0 00 00 00 00 0800
36) DONE: Мур --- третий способ ДК АК
        0:0 00 00 01 01 0001
        1:0 02 02 02 02 0144 сброс СТ
        2:0 03 03 03 03 0090 инкремент СТ
        3:1 07 04 05 07 0000
        4:0 07 07 07 07 0200
        5:0 07 07 07 07 0220
        6:0 03 03 03 03 0488 сдвиг
        7:2 06 08 06 08 0000 анализ
        8:0 08 09 08 09 0002
        9:0 0a 0a 0a 0a 1000
        a:0 00 00 00 00 0800
35) DONE: Мур --- второй способ ДК АК
        0:0 00 00 01 01 0001
        1:0 02 02 02 02 0284
        2:0 03 03 03 03 0010
        3:1 06 04 05 06 0000
        4:0 06 06 06 06 0400
        5:0 06 06 06 06 0440
        6:0 07 07 07 07 0128
        7:2 03 08 03 08 0000
        8:0 08 09 08 09 0002
        9:0 0a 0a 0a 0a 1000
        a:0 00 00 00 00 0800
34) DONE: Мур --- первый способ ДК АК
        0:0 00 00 01 01 0001
        1:0 02 02 02 02 0144
        2:0 03 03 03 03 0010
        3:1 06 04 05 06 0000
        4:0 06 06 06 06 0200
        5:0 06 06 06 06 0220
        6:0 07 07 07 07 0488
        7:2 03 08 03 08 0000
        8:0 08 09 08 09 0002
        9:0 0a 0a 0a 0a 1000
        a:0 00 00 00 00 0800
33) DONE: Мур --- четвертый способ ДК РК
        0:1 00 01 0001
        1:0 02 02 0244
        2:0 03 03 0010
        3:2 05 04 0000
        4:0 05 05 0880
        5:3 07 06 0000
        6:0 07 07 0980
        7:2 09 08 0020
        8:0 09 09 0080
        9:0 0a 0a 0408
        a:4 07 0b 0000
        b:0 0b 0c 0002
        c:0 0d 0d 2000
        d:0 00 00 1000
32) DONE: Мур --- третий способ ДК РК.
        0:1 00 01 0001
        1:0 02 02 0224
        2:0 03 03 0010
        3:2 05 04 0000
        4:0 05 05 0840
        5:3 07 06 0000
        6:0 07 07 0940
        7:2 09 08 0080
        8:0 09 09 0040
        9:0 0a 0a 0408
        a:4 07 0b 0000
        b:0 0b 0c 0002
        c:0 0d 0d 2000
        d:0 00 00 1000
31) DONE: Мур --- не подписан столбец комментария в табличке микропрограммы.
30) DONE: Второй способ умножения в ДК с РК Мур:
        0:1 00 01 0001
        1:0 02 02 0244
        2:1 03 03 0010
        3:3 05 04 0000
        4:0 05 05 0080
        5:0 06 06 0428
        6:2 03 07 0000
        7:4 09 08 0000
        8:0 09 09 0880
        9:5 0b 0a 0000
        a:0 0b 0b 0980
        b:0 0b 0c 0002
        c:0 0d 0d 2000
        d:0 00 00 1000
29) DONE: Первый способ умножения с ручной коррекцией. Пройден отладочный тест и автотесты.
          о s0 s1 y
        0:1 00 01 0001
        1:0 02 02 0094
        2:0 03 03 0040
        3:3 05 04 0000
        4:0 05 05 0100
        5:0 06 06 0228
        6:2 03 07 0000
        7:4 09 08 0000
        8:0 09 09 1900
        9:5 0b 0a 0000
        a:0 0b 0b 1d00
        b:0 0b 0c 0002
        c:0 0d 0d 4000
        d:0 00 00 2000
28) FIXED: Некорректное отображение размерности мультиплексора 2 в автомате Мура(2)
27) DONE: Писать в счетчик сдвигов (сложений) 1 или 0, так как у нас есть два такта считывания данных, чтобы подогнать
    подходящий выход к концу алгоритма и подогнать подходящее количество тактов для своевременной выдачи CT[3].
25) DONE: Проверить на возниконовение ошибки 'конфликт управления регистром'
24) DONE: Обновить картинки для автоматов, сделать подписи на плечах мультиплексоров
23) FIXED: Окошко сообщения об успешном прохождении тестов должно конкретизировать режим:
    'Отладочный тест пройден'
    'Автоматические тесты пройдены'
22) DONE: ПК 1
22) DONE: Отладка в автоматических режимах:
    22.9) DONE: ПК IV
            0:1 00 01 0001
            1:0 02 02 0514
            2:0 03 03 0840
            3:3 05 04 0000
            4:0 05 05 0200
            5:0 06 06 00a8
            6:2 03 07 0000
            7:0 07 08 0002
            8:0 09 09 2000
            9:0 00 00 1000
    22.8) DONE: ПК III
            0:1 00 01 0001
            1:0 02 02 0494
            2:0 03 03 0840
            3:3 05 04 0000
            4:0 05 05 0100
            5:2 06 07 0000
            6:0 03 03 0228
            7:0 07 08 0002
            8:0 09 09 2000
            9:0 00 00 1000
    22.7) DONE: Отладка/автотест Мура ПК II
           j s0 s1 Y
        0: 1 00 01 0001 READY
        1: 0 02 02 0514 Rg1,CT1
        2: 0 03 03 0840 Rg2
        3: 3 05 04 0000
        4: 0 05 05 0200 wr(+)
        5: 0 06 06 00a8 shifts
        6: 2 03 07 0000
        7: 0 07 08 0002
        8: 0 09 09 2000
        9: 0 00 00 1000
    22.6) DONE: Проверить в режиме отладки автомат Мили(x2) ПК II
            j s0 y0   s1 y1    Comment
         0: 1 00 0001 01 0001  Ready
         1: 0 02 0414 02 0414  RG1:=D[6:0],CT=0010,T1=D[7]
         2: 0 03 08c0 03 08c0  RG2:=D[6:0],CT++,T2=D[7]
         3: 3 05 0228 04 0100  p3 ? {RG1>>1, RG2>>1, CT++}/5 : {RG3:=SM}/4
         4: 0 05 0228 05 0228  RG1>>1, RG2>>1, CT++
         5: 2 03 0000 06 0000  p2 ? /3 : /6
         6: 3 07 0002 07 0100  p3 ? READY/7 : {RG3:=SM}/7
         7: 0 07 0002 08 0002  p0 ? RESULT/7 : RESULT/8
         8: 0 09 2000 09 2000  D=BD2
         9: 0 00 1000 00 1000  D=BD1
    22.5) FIXED: При начале отладки обновлять вид, так как в начале отладки регистр адреса сброшен, а текущая строка не подсвечена (set)
    22.4) DONE: Проверить в режиме автотестирования автомат Мура(x2) (умножение в ПК первым способом)
    22.3) DONE: Проверить в режиме отладки автомат Мура(x2) (умножение в ПК первым способом, ПК I)
           j s0 s1 Y
        0: 1 00 01 0001  READY to CPU
        1: 0 02 02 0414  Rg1:=D[6:0],CT1:=0010,T1=D[7]
        2: 0 03 03 08C0  Rg2:=D, CT1++
        3: 3 05 04 0000 loop: sign analysis
        4: 0 05 05 0100  Rg3+=Rg2
        5: 0 06 06 0228  shifts,Ct++
        6: 2 03 07 0000  p2 ? 3 : 7; nop
        7: 3 09 08 0000  p3 ? 9 : 8; sign analysis
        8: 0 09 09 0100  Rg3+=Rg2
        9: 0 09 0A 0002  p0 ? loopself(RESULT) : out;
        A: 0 0B 0B 2000  D=BD1
        B: 0 00 00 1000  D=BD2
    22.2) FIXED: Сброс регистра состояний в режиме отладки, тестирования для автоматических режимов не происходит!
    22.1) FIXED: При выборе сторки в автоматическом MCU также обновлять виды...
21) FIXED: При переключении MCU --- обновить состояние и Hints ? (почему hints обновляются для ручного режима),
    перейти в режим 'программирование'
19) FIXED: Запрещать редактирование ячеек таблицы ROM в режиме программирования...
18) DONE: При обновлении данных в таблице ROM --- обновлять UI...
17) DONE: Pi=CT1[3] --- STOP
16) DONE: Писать в два младших разряда счетчика (y2,y1) - пусть сами подбирают значение 8-{0,1,2,3} = {8,7,6,5}...
          Нет: это слишком сложно для студентов. Нужно выверить константы инициализации счетчика.
15) DONE: Выдавать ошибку протокола, когда в CPU выдается сигнал READY после сигнала BUS
14) DONE: RomAddress в базовый класс CMcu ?
13) DONE: Сделать Randomize (SetSeed(time)) или чето в этом роде --- задрала повторяемость
12) FIXED: Сумматор не обновляется при выполнении шага!
11) DONE: Подписать таблицу ROM "ПЗУ(Микрокоманды)" в ручном режиме, и "ПЗУ(Микропрограмма)" в автоматическом...
11) DONE: В режиме отладки микропрограммных автоматов запрещать выбор строки вручную в виджете-таблице микропрограммы.
10) DONE: Обработать ошибки ввода в режиме отладки и не начинать выполнение теста, если пользователь не ввел данные
9) MEMO: сохраняем картинки в следующем формате:
        Без чередования, 16 цветов, экран,
8) DONE: Сделать callback для считывания событий из UI в модельном методе IsExternalBreakChecked.
7) DONE: Реализовать управления actions
6) DONE: Проверку теста вынести в родительский класс, в дочернем перегружать метод "отдай i-ю часть верного результата"
5) DONE: Сделать картинки для actions
4) DONE: Сделать обработку перемещений по истории в ручном режиме
3) Сделать QLabel непереводимым, чтобы уменьшить работу переводчика!
2) DONE: Отладка в ручном режиме
    2.12) DONE: Пройти в отладчике -1*1 с точкой останова на ShiftToHalt.
    2.11) DONE: Сброс состояния в Alu при начале тестирования (отладки/автотестов)
    2.10) FIXED: Некорректно отображается состояние логики
          MEMO:  Всю логику следует реализовывать функциями, результаты работы которых зависят от элементов памяти
    2.9) FIXED: Не обновляются значения триггеров
    2.8) FIXED: Ввести виртуальный метод DataOutsCount()
    2.7) FIXED: '********'. Решить, что выводить при конфликте шины
    2.6) FIXED: Решить, что следует заносить в регистры при попытке чтения с шины, на которой нет данных? 00000000?
         Заносим: 00000000
    2.5) FIXED: Не работают сдвиги регистров (нет отображения)
    2.4) FIXED: Использовать TextOut где возможно
    2.3) FIXED: Не распространяются сигналы по ФС первого способа (триггеры не обновляются)
    2.2) FIXED: Не работает выдача на шину
    2.1) Не обновляются хинты регистра состояния, отображение значения регистра меняется по длине
         FIXED: bad binary dimension
1) FIXED: Выяснить, почему в первом способе ПК без ускорения размерность осведомительных сигналов --- 3, достаточно 2?
    MinDimensionFor(GroupCount - 1) vs wrong: MinDimensionFor(GroupCount)
